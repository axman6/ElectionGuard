{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RecordWildCards     #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TypeOperators       #-}
{-# LANGUAGE DeriveGeneric       #-}
{-# LANGUAGE DerivingStrategies #-}
-- | DO NOT EDIT THIS FILE MANUALLY!
--   It was automatically generated by `json-autotype`.
module JSONTypes where
import           System.Exit        (exitFailure, exitSuccess)
import           System.IO          (stderr, hPutStrLn)
import qualified Data.ByteString.Lazy.Char8 as BSL
import           System.Environment (getArgs)
import           Control.Monad      (forM_, mzero)
import           Data.Aeson.AutoType.Alternative ( type (:|:) )
import           Data.Aeson(eitherDecode, Value(..), FromJSON(..), ToJSON(..),pairs,(.:), (.:?), (.=), object)
import           Data.Text (Text)
import qualified GHC.Generics

data EncryptedMessage = EncryptedMessage {
    encryptedMessagePublicKey :: Text,
    encryptedMessageCiphertext :: Text
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON EncryptedMessage where
  parseJSON (Object v) = EncryptedMessage <$> v .:  "public_key" <*> v .:  "ciphertext"
  parseJSON _          = mzero


instance ToJSON EncryptedMessage where
  toJSON     EncryptedMessage {..} = object ["public_key" .= encryptedMessagePublicKey, "ciphertext" .= encryptedMessageCiphertext]
  toEncoding EncryptedMessage {..} = pairs  ("public_key" .= encryptedMessagePublicKey<>"ciphertext" .= encryptedMessageCiphertext)


data ZeroProof = ZeroProof {
    zeroProofChallenge :: Text,
    zeroProofResponse :: Text,
    zeroProofCommitment :: Text:|:EncryptedMessage:|:[Maybe Value]
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON ZeroProof where
  parseJSON (Object v) = ZeroProof <$> v .:  "challenge" <*> v .:  "response" <*> v .:  "commitment"
  parseJSON _          = mzero


instance ToJSON ZeroProof where
  toJSON     ZeroProof {..} = object ["challenge" .= zeroProofChallenge, "response" .= zeroProofResponse, "commitment" .= zeroProofCommitment]
  toEncoding ZeroProof {..} = pairs  ("challenge" .= zeroProofChallenge<>"response" .= zeroProofResponse<>"commitment" .= zeroProofCommitment)


data TrusteePublicKeysEltElt = TrusteePublicKeysEltElt {
    trusteePublicKeysEltEltPublicKey :: Text,
    trusteePublicKeysEltEltProof :: ZeroProof
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON TrusteePublicKeysEltElt where
  parseJSON (Object v) = TrusteePublicKeysEltElt <$> v .:  "public_key" <*> v .:  "proof"
  parseJSON _          = mzero


instance ToJSON TrusteePublicKeysEltElt where
  toJSON     TrusteePublicKeysEltElt {..} = object ["public_key" .= trusteePublicKeysEltEltPublicKey, "proof" .= trusteePublicKeysEltEltProof]
  toEncoding TrusteePublicKeysEltElt {..} = pairs  ("public_key" .= trusteePublicKeysEltEltPublicKey<>"proof" .= trusteePublicKeysEltEltProof)


data SharesElt = SharesElt {
    sharesEltRecovery :: Maybe Value,
    sharesEltShare :: Text,
    sharesEltProof :: ZeroProof:|:[Maybe Value]
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON SharesElt where
  parseJSON (Object v) = SharesElt <$> v .:? "recovery" <*> v .:  "share" <*> v .:  "proof"
  parseJSON _          = mzero


instance ToJSON SharesElt where
  toJSON     SharesElt {..} = object ["recovery" .= sharesEltRecovery, "share" .= sharesEltShare, "proof" .= sharesEltProof]
  toEncoding SharesElt {..} = pairs  ("recovery" .= sharesEltRecovery<>"share" .= sharesEltShare<>"proof" .= sharesEltProof)


data ContestTalliesEltElt = ContestTalliesEltElt {
    contestTalliesEltEltDecryptedTally :: Text,
    contestTalliesEltEltShares :: [SharesElt],
    contestTalliesEltEltEncryptedTally :: EncryptedMessage,
    contestTalliesEltEltCleartext :: Text
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON ContestTalliesEltElt where
  parseJSON (Object v) = ContestTalliesEltElt <$> v .:  "decrypted_tally" <*> v .:  "shares" <*> v .:  "encrypted_tally" <*> v .:  "cleartext"
  parseJSON _          = mzero


instance ToJSON ContestTalliesEltElt where
  toJSON     ContestTalliesEltElt {..} = object ["decrypted_tally" .= contestTalliesEltEltDecryptedTally, "shares" .= contestTalliesEltEltShares, "encrypted_tally" .= contestTalliesEltEltEncryptedTally, "cleartext" .= contestTalliesEltEltCleartext]
  toEncoding ContestTalliesEltElt {..} = pairs  ("decrypted_tally" .= contestTalliesEltEltDecryptedTally<>"shares" .= contestTalliesEltEltShares<>"encrypted_tally" .= contestTalliesEltEltEncryptedTally<>"cleartext" .= contestTalliesEltEltCleartext)


data SelectionsElt = SelectionsElt {
    selectionsEltOneProof :: ZeroProof,
    selectionsEltMessage :: EncryptedMessage,
    selectionsEltZeroProof :: ZeroProof
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON SelectionsElt where
  parseJSON (Object v) = SelectionsElt <$> v .:  "one_proof" <*> v .:  "message" <*> v .:  "zero_proof"
  parseJSON _          = mzero


instance ToJSON SelectionsElt where
  toJSON     SelectionsElt {..} = object ["one_proof" .= selectionsEltOneProof, "message" .= selectionsEltMessage, "zero_proof" .= selectionsEltZeroProof]
  toEncoding SelectionsElt {..} = pairs  ("one_proof" .= selectionsEltOneProof<>"message" .= selectionsEltMessage<>"zero_proof" .= selectionsEltZeroProof)


data ContestsElt = ContestsElt {
    contestsEltNumSelectionsProof :: ZeroProof,
    contestsEltSelections :: [SelectionsElt],
    contestsEltMaxSelections :: Text
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON ContestsElt where
  parseJSON (Object v) = ContestsElt <$> v .:  "num_selections_proof" <*> v .:  "selections" <*> v .:  "max_selections"
  parseJSON _          = mzero


instance ToJSON ContestsElt where
  toJSON     ContestsElt {..} = object ["num_selections_proof" .= contestsEltNumSelectionsProof, "selections" .= contestsEltSelections, "max_selections" .= contestsEltMaxSelections]
  toEncoding ContestsElt {..} = pairs  ("num_selections_proof" .= contestsEltNumSelectionsProof<>"selections" .= contestsEltSelections<>"max_selections" .= contestsEltMaxSelections)


data ContestsEltElt = ContestsEltElt {
    contestsEltEltShares :: [SharesElt],
    contestsEltEltDecryptedMessage :: Text,
    contestsEltEltCleartext :: Text,
    contestsEltEltEncryptedMessage :: EncryptedMessage
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON ContestsEltElt where
  parseJSON (Object v) = ContestsEltElt <$> v .:  "shares" <*> v .:  "decrypted_message" <*> v .:  "cleartext" <*> v .:  "encrypted_message"
  parseJSON _          = mzero


instance ToJSON ContestsEltElt where
  toJSON     ContestsEltElt {..} = object ["shares" .= contestsEltEltShares, "decrypted_message" .= contestsEltEltDecryptedMessage, "cleartext" .= contestsEltEltCleartext, "encrypted_message" .= contestsEltEltEncryptedMessage]
  toEncoding ContestsEltElt {..} = pairs  ("shares" .= contestsEltEltShares<>"decrypted_message" .= contestsEltEltDecryptedMessage<>"cleartext" .= contestsEltEltCleartext<>"encrypted_message" .= contestsEltEltEncryptedMessage)


data BallotInfo = BallotInfo {
    ballotInfoDeviceInfo :: Text,
    ballotInfoTracker :: Text,
    ballotInfoDate :: Text,
    ballotInfoTime :: Text
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON BallotInfo where
  parseJSON (Object v) = BallotInfo <$> v .:  "device_info" <*> v .:  "tracker" <*> v .:  "date" <*> v .:  "time"
  parseJSON _          = mzero


instance ToJSON BallotInfo where
  toJSON     BallotInfo {..} = object ["device_info" .= ballotInfoDeviceInfo, "tracker" .= ballotInfoTracker, "date" .= ballotInfoDate, "time" .= ballotInfoTime]
  toEncoding BallotInfo {..} = pairs  ("device_info" .= ballotInfoDeviceInfo<>"tracker" .= ballotInfoTracker<>"date" .= ballotInfoDate<>"time" .= ballotInfoTime)


data SpoiledBallotsElt = SpoiledBallotsElt {
    spoiledBallotsEltContests :: [ContestsElt:|:[ContestsEltElt]],
    spoiledBallotsEltBallotInfo :: BallotInfo:|:[Maybe Value]
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON SpoiledBallotsElt where
  parseJSON (Object v) = SpoiledBallotsElt <$> v .:  "contests" <*> v .:  "ballot_info"
  parseJSON _          = mzero


instance ToJSON SpoiledBallotsElt where
  toJSON     SpoiledBallotsElt {..} = object ["contests" .= spoiledBallotsEltContests, "ballot_info" .= spoiledBallotsEltBallotInfo]
  toEncoding SpoiledBallotsElt {..} = pairs  ("contests" .= spoiledBallotsEltContests<>"ballot_info" .= spoiledBallotsEltBallotInfo)


data Parameters = Parameters {
    parametersThreshold :: Text,
    parametersNumTrustees :: Text,
    parametersGenerator :: Text,
    parametersDate :: Text,
    parametersPrime :: Text,
    parametersLocation :: Text
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON Parameters where
  parseJSON (Object v) = Parameters <$> v .:  "threshold" <*> v .:  "num_trustees" <*> v .:  "generator" <*> v .:  "date" <*> v .:  "prime" <*> v .:  "location"
  parseJSON _          = mzero


instance ToJSON Parameters where
  toJSON     Parameters {..} = object ["threshold" .= parametersThreshold, "num_trustees" .= parametersNumTrustees, "generator" .= parametersGenerator, "date" .= parametersDate, "prime" .= parametersPrime, "location" .= parametersLocation]
  toEncoding Parameters {..} = pairs  ("threshold" .= parametersThreshold<>"num_trustees" .= parametersNumTrustees<>"generator" .= parametersGenerator<>"date" .= parametersDate<>"prime" .= parametersPrime<>"location" .= parametersLocation)


data TopLevel = TopLevel {
    topLevelTrusteePublicKeys :: [[TrusteePublicKeysEltElt]],
    topLevelContestTallies :: [[ContestTalliesEltElt]],
    topLevelCastBallots :: [SpoiledBallotsElt],
    topLevelJointPublicKey :: Text,
    topLevelExtendedBaseHash :: Text,
    topLevelSpoiledBallots :: [SpoiledBallotsElt],
    topLevelBaseHash :: Text,
    topLevelParameters :: Parameters
  } deriving stock (Show,Eq,GHC.Generics.Generic)


instance FromJSON TopLevel where
  parseJSON (Object v) = TopLevel <$> v .:  "trustee_public_keys" <*> v .:  "contest_tallies" <*> v .:  "cast_ballots" <*> v .:  "joint_public_key" <*> v .:  "extended_base_hash" <*> v .:  "spoiled_ballots" <*> v .:  "base_hash" <*> v .:  "parameters"
  parseJSON _          = mzero


instance ToJSON TopLevel where
  toJSON     TopLevel {..} = object
    [ "trustee_public_keys" .= topLevelTrusteePublicKeys
    , "contest_tallies" .= topLevelContestTallies
    , "cast_ballots" .= topLevelCastBallots
    , "joint_public_key" .= topLevelJointPublicKey
    , "extended_base_hash" .= topLevelExtendedBaseHash
    , "spoiled_ballots" .= topLevelSpoiledBallots
    , "base_hash" .= topLevelBaseHash
    , "parameters" .= topLevelParameters]
  toEncoding TopLevel {..} = pairs
    ( "trustee_public_keys" .= topLevelTrusteePublicKeys
    <>"contest_tallies" .= topLevelContestTallies
    <>"cast_ballots" .= topLevelCastBallots
    <>"joint_public_key" .= topLevelJointPublicKey
    <>"extended_base_hash" .= topLevelExtendedBaseHash
    <>"spoiled_ballots" .= topLevelSpoiledBallots
    <>"base_hash" .= topLevelBaseHash
    <>"parameters" .= topLevelParameters)





-- | Use parser to get TopLevel object
parse :: FilePath -> IO TopLevel
parse filename = do
    input <- BSL.readFile filename
    case eitherDecode input of
      Left errTop -> fatal $ case (eitherDecode input :: Either String Value) of
                           Left  err -> "Invalid JSON file: " ++ filename ++ "\n   " ++ err
                           Right _   -> "Mismatched JSON value from file: " ++ filename
                                     ++ "\n" ++ errTop
      Right r     -> return (r :: TopLevel)
  where
    fatal :: String -> IO a
    fatal msg = do hPutStrLn stderr msg
                   exitFailure

-- | For quick testing
main :: IO ()
main = do
  filenames <- getArgs
  forM_ filenames (\f -> parse f >>= (\p -> p `seq` putStrLn $ "Successfully parsed " ++ f))
  exitSuccess

